---
layout: post
title: Linux 常用50个命令之04 - nohup
categories: [Linux]
tags: [Linux]
fullview: false
comments: true
---
---
`nohup`命令可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。
无论是否将 `nohup` 命令的输出重定向到终端，输出都将附加到当前目录的 `nohup.out` 文件中。
如果当前目录的 `nohup.out` 文件不可写，输出重定向到`$HOME/nohup.out`文件中。
如果没有文件能创建或打开以用于追加，那么 `command` 参数指定的命令不可调用。
如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。


#### 1, 语法
nohup(选项)(参数) `nohup` 代表 `no hangup`

```
nohup command > myout.file 2>&1 &
```

#### 2，`&`
`&` 是把该命令以后台的job的形式运行

#### 3， `2>&1` 和 `/dev/null`
我们在linux下经常会碰到`nohup command>/dev/null 2>&1 &`这样形式的命令。首先我们把这条命令大概分解下首先就是一个`nohup`表示当前用户和系统的回话下的进城忽略响应HUP消息。`&`是把该命令以后台的job的形式运行。那么就剩下`command>/dev/null 2>&1`,`command>/dev/null`较好理解，`/dev/null`表示一个空设备，就是说吧`command`的执行结果重定向到空设备中，说白了就是不显示任何信息。那么`2>&1`又是什么含义?

* /dev/null 表示空设备文件
* 0 表示stdin标准输入
* 1 表示stdout标准输出
* 2 表示stderr标准错误

---

##### 3.1 从`command>/dev/null`说起

其实这条命令是一个缩写版，对于一个重定向命令，肯定是`a > b`这种形式，那么`command > /dev/null`难道是`command`充当`a`的角色，`/dev/null`充当`b`的角色。这样看起来比较合理，其实一条命令肯定是充当不了`a`，肯定是`command`执行产生的输出来充当`a`，其实就是标准输出`stdout`。所以`command > /dev/null`相当于执行了`command 1 > /dev/null`。执行`command`产生了标准输出`stdout`(用`1`表示)，重定向到`/dev/null`的设备文件中。

##### 3.2 说说2>&1

通过上面`command > /dev/null`等价于`command 1 > /dev/null`,那么对于 `2>&1`也就好理解了，`2`就是标准错误，`1`是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是`&1`而不是`1`，这里`&`是什么？这里`&`相当于等效于标准输出。这里有点不好理解，先看下面。


##### 3.3 `command>a 2>a` 与 `command>a 2>&1`的区别

通过上面的分析，对于`command>a 2>&1`这条命令，等价于`command 1>a 2>&1`可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说command 1>a 2>&1等价于command 1>a 2>a呢。其实不是，command 1>a 2>&1与command 1>a 2>a还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。&1的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，command 1>a 2>&1比command 1>a 2>a的效率更高。
